{"version":3,"sources":["index.ts"],"names":["clientState","ClientState","Disconnected","updateReady","contextId","isReady","readyDiv","document","getElementById","innerHTML","resetState","window","onload","client","appId","process","undefined","Error","language","opts","debug","logSegments","loginUrl","apiUrl","Client","newClient","e","status","statusDiv","updateStatus","message","onSegmentChange","segment","words","entities","intent","map","word","isFinal","value","join","index","entity","t","type","startPosition","endPosition","cleanedWords","filter","w","segmentId","intents","logDiv","JSON","stringify","logResponse","id","startRecording","event","a","preventDefault","startContext","console","error","stopRecording","stopContext","recordDiv","addEventListener","initDiv","onStateChange","state","Connected","setAttribute","removeAttribute","Stopping","stateToString","bindStartStop","initialize","button","target","close","bindInitialize"],"mappings":"oMAWIA,EAAcC,cAAYC,aA+G9B,SAASC,EAAYC,EAAmBC,GACtC,IAAMC,EAAWC,SAASC,eAAe,SAGvCF,EAASG,UADPJ,EACF,yBAAuCD,EAAvC,UAEA,yBAAuCA,GA4G3C,SAASM,EAAWN,GAClBD,EAAYC,GAAW,GAEJG,SAASC,eAAe,oBAChCC,UAAY,GAEAF,SAASC,eAC9B,mBAEaC,UAAY,GAEXF,SAASC,eAAe,YAChCC,UAAY,GAECF,SAASC,eAAe,iBAChCC,UAAY,GA9O3BE,OAAOC,OAAS,WACd,IAAIC,EAEJ,IACEA,EAiCJ,WACE,IAAMC,EAAQC,uCACd,QAAcC,IAAVF,EACF,MAAMG,MAAM,4BAGd,IAAMC,EAAWH,QACjB,QAAiBC,IAAbE,EACF,MAAMD,MAAM,kCAGd,IAAME,EAAsB,CAC1BL,QACAI,WACAE,OAAOL,EAGPM,aAAa,GAIbF,EAAKG,SAAWP,qCAIhBI,EAAKI,OAASR,mCAGhB,OAAO,IAAIS,SAAOL,GA7DPM,GACT,MAAOC,GAEP,YAqIJ,SAAsBC,GACpB,IAAMC,EAAYrB,SAASC,eAAe,UAC1C,GAAkB,OAAdoB,EACF,OAGFA,EAAUnB,UAAYkB,EA5IpBE,CAAaH,EAAEI,SAKjBjB,EAAOkB,iBAAgB,SAACC,GAyD1B,IAAqBC,EAmBGC,EAcFC,EAjCDF,EAxDLD,EAAQC,MAyDA1B,SAASC,eAC7B,oBAGYC,UAAYwB,EACvBG,KAAI,SAACC,GAAD,OAAWA,EAAKC,QAAL,aAAqBD,EAAKE,MAA1B,QAAwCF,EAAKE,SAC5DC,KAAK,KAESjC,SAASC,eAAe,mBAChCC,UAAYwB,EAClBG,KAAI,SAACC,GAAD,OACHA,EAAKC,QAAL,iBACcD,EAAKE,MADnB,aAC6BF,EAAKI,MADlC,4BAEWJ,EAAKE,MAFhB,aAE0BF,EAAKI,MAF/B,aAIDD,KAAK,IAGcN,EA1ELF,EAAQE,SA2EL3B,SAASC,eAAe,iBAEhCC,UAAYyB,EACrBE,KAAI,SAACM,GACJ,IAAMC,EAAC,UAAMD,EAAOE,KAAb,cAAuBF,EAAOH,MAA9B,aAAwCG,EAAOG,cAA/C,cAAkEH,EAAOI,YAAzE,KACP,OAAIJ,EAAOJ,QACH,UAAN,OAAiBK,EAAjB,aAEI,OAAN,OAAcA,EAAd,YAEDH,KAAK,IAGYL,EAvFLH,EAAQG,OAwFL5B,SAASC,eAAe,gBAEhCC,UAAY0B,EAAOG,QAAP,aACZH,EAAOA,OADK,QAElBA,EAAOA,OA1FLH,EAAQM,SACVnC,EAAY6B,EAAQ5B,WAAW,GAGjC,IAAM2C,EAAef,EAAQC,MAAMe,QAAO,SAACC,GAAD,OAAaA,EAAEV,SAAOH,KAC9D,SAACa,GAAD,MAAc,CAACV,MAAMU,EAAEV,MAAOE,MAAMQ,EAAER,WAkG5C,SACErC,EACA8C,EACAZ,EACAL,EACAkB,EACAjB,GAEA,IAAMkB,EAAS7C,SAASC,eAAe,YAEvC4C,EAAO3C,UACL,8BACYL,EADZ,gCAEY8C,EAFZ,gCAGYZ,EAHZ,gCAIYe,KAAKC,UAAUrB,GAJ3B,gCAKYoB,KAAKC,UAAUH,GAL3B,gCAMYE,KAAKC,UAAUpB,GAN3B,wBAOakB,EAAO3C,UAjHpB8C,CACEvB,EAAQ5B,UACR4B,EAAQwB,GACRxB,EAAQM,QACRS,EACAf,EAAQG,OACRH,EAAQE,aAuHd,SAAuBrB,GACrB,IAAM4C,EAAc,uCAAG,WAAOC,GAAP,SAAAC,EAAA,6DACrBD,EAAME,iBADe,kBAIK/C,EAAOgD,eAJZ,OAKnBnD,EALmB,wDAOnBoD,QAAQC,MAAM,4BAAd,MAPmB,yDAAH,sDAWdC,EAAa,uCAAG,WAAON,GAAP,SAAAC,EAAA,6DACpBD,EAAME,iBADc,kBAIZ/C,EAAOoD,cAJK,sDAMlBH,QAAQC,MAAM,2BAAd,MANkB,wDAAH,sDAUbG,EAAY3D,SAASC,eAAe,UAC1C0D,EAAUC,iBAAiB,YAAaV,GACxCS,EAAUC,iBAAiB,aAAcV,GACzCS,EAAUC,iBAAiB,UAAWH,GACtCE,EAAUC,iBAAiB,WAAYH,GAEvC,IAAMI,EAAU7D,SAASC,eAAe,cACxCK,EAAOwD,eAAc,SAACC,GACpBtE,EAAcsE,EAEVA,IAAUrE,cAAYsE,WAAaD,IAAUrE,cAAYC,aAC3DkE,EAAQI,aAAa,WAAY,YAEjCJ,EAAQK,gBAAgB,YAGtBH,EAAQrE,cAAYsE,WAAaD,IAAUrE,cAAYyE,SACzDR,EAAUM,aAAa,WAAY,YAEnCN,EAAUO,gBAAgB,YAGVlE,SAASC,eAAe,UAChCC,UAAYkE,wBAAcL,MAjKtCM,CAAc/D,GAqKhB,SAAwBA,GACtB,IAAMgE,EAAU,uCAAG,WAAOnB,GAAP,eAAAC,EAAA,yDACjBD,EAAME,iBACAkB,EAASpB,EAAMqB,OAFJ,SAKX/E,IAAgBC,cAAYC,aALjB,gCAMPW,EAAOgE,aANA,OAObC,EAAOrE,UAAY,aAPN,0BAQJT,IAAgBC,cAAYsE,UARxB,kCASP1D,EAAOmE,QATA,QAUbF,EAAOrE,UAAY,UAVN,0DAafqD,QAAQC,MAAM,sCAAd,MAbe,4FAAH,sDAmBVK,EAAU7D,SAASC,eAAe,cACxC4D,EAAQD,iBAAiB,YAAaU,GACtCT,EAAQD,iBAAiB,aAAcU,GA1LvCI,CAAepE,M","file":"static/js/main.8e1ca97b.chunk.js","sourcesContent":["import {\n  Client,\n  ClientState,\n  stateToString,\n  Word,\n  Entity,\n  Intent,\n  ClientOptions,\n  Segment,\n} from \"@speechly/browser-client\";\n\nlet clientState = ClientState.Disconnected;\n\nwindow.onload = () => {\n  let client: Client;\n\n  try {\n    client = newClient();\n  } catch (e) {\n    updateStatus(e.message);\n    return;\n  }\n\n  // High-level API, that you can use to react to segment changes.\n  client.onSegmentChange((segment: Segment) => {\n    updateWords(segment.words);\n    updateEntities(segment.entities);\n    updateIntent(segment.intent);\n\n    if (segment.isFinal) {\n      updateReady(segment.contextId, true);\n    }\n\n    const cleanedWords = segment.words.filter((w: Word) => w.value).map(\n      (w: Word) => ({value:w.value, index:w.index})\n    )\n\n    logResponse(\n      segment.contextId,\n      segment.id,\n      segment.isFinal,\n      cleanedWords,\n      segment.intent,\n      segment.entities)\n  });\n\n  bindStartStop(client);\n  bindInitialize(client);\n};\n\nfunction newClient(): Client {\n  const appId = process.env.REACT_APP_APP_ID;\n  if (appId === undefined) {\n    throw Error(\"Missing Speechly app ID!\");\n  }\n\n  const language = process.env.REACT_APP_LANGUAGE;\n  if (language === undefined) {\n    throw Error(\"Missing Speechly app language!\");\n  }\n\n  const opts: ClientOptions = {\n    appId,\n    language,\n    debug: process.env.REACT_APP_DEBUG === \"true\",\n    // Enabling logSegments logs the updates to segment (transcript, intent and entities) to console.\n    // Consider turning it off in the production as it has extra JSON.stringify operation.\n    logSegments: true\n  };\n\n  if (process.env.REACT_APP_LOGIN_URL !== undefined) {\n    opts.loginUrl = process.env.REACT_APP_LOGIN_URL;\n  }\n\n  if (process.env.REACT_APP_API_URL !== undefined) {\n    opts.apiUrl = process.env.REACT_APP_API_URL;\n  }\n\n  return new Client(opts);\n}\n\nfunction updateWords(words: Word[]) {\n  const transcriptDiv = document.getElementById(\n    \"transcript-words\"\n  ) as HTMLElement;\n\n  transcriptDiv.innerHTML = words\n    .map((word) => (word.isFinal ? `<b>${word.value}</b>` : word.value))\n    .join(\" \");\n\n  const wordsDiv = document.getElementById(\"transcript-list\") as HTMLElement;\n  wordsDiv.innerHTML = words\n    .map((word) =>\n      word.isFinal\n        ? `<li><b>${word.value} [${word.index}]</b></li>`\n        : `<li>${word.value} [${word.index}]</li>`\n    )\n    .join(\"\");\n}\n\nfunction updateEntities(entities: Entity[]) {\n  const entitiesDiv = document.getElementById(\"entities-list\") as HTMLElement;\n\n  entitiesDiv.innerHTML = entities\n    .map((entity) => {\n      const t = `${entity.type} - ${entity.value} [${entity.startPosition} - ${entity.endPosition})`;\n      if (entity.isFinal) {\n        return `<li><b>${t}</b></li>`;\n      }\n      return `<li>${t}</li>`;\n    })\n    .join(\"\");\n}\n\nfunction updateIntent(intent: Intent) {\n  const intentDiv = document.getElementById(\"intent-value\") as HTMLElement;\n\n  intentDiv.innerHTML = intent.isFinal\n    ? `<b>${intent.intent}</b>`\n    : intent.intent;\n}\n\nfunction updateReady(contextId: string, isReady: boolean) {\n  const readyDiv = document.getElementById(\"final\") as HTMLElement;\n\n  if (isReady) {\n    readyDiv.innerHTML = `<b>Context</b> ${contextId} Done!`;\n  } else {\n    readyDiv.innerHTML = `<b>Context</b> ${contextId}`;\n  }\n}\n\nfunction logResponse(\n  contextId: string,\n  segmentId: number,\n  isFinal: boolean,\n  words: any,\n  intents: any,\n  entities: any,\n) {\n  const logDiv = document.getElementById(\"log-list\") as HTMLElement;\n\n  logDiv.innerHTML =\n    `<tr>\n          <td>${contextId}</td>\n          <td>${segmentId}</td>\n          <td>${isFinal}</td>\n          <td>${JSON.stringify(words)}</td>\n          <td>${JSON.stringify(intents)}</td>\n          <td>${JSON.stringify(entities)}</td>\n        </tr>` + logDiv.innerHTML;\n}\n\nfunction updateStatus(status: string): void {\n  const statusDiv = document.getElementById(\"status\");\n  if (statusDiv === null) {\n    return;\n  }\n\n  statusDiv.innerHTML = status;\n}\n\nfunction bindStartStop(client: Client) {\n  const startRecording = async (event: MouseEvent | TouchEvent) => {\n    event.preventDefault();\n\n    try {\n      const contextId = await client.startContext();\n      resetState(contextId);\n    } catch (err) {\n      console.error(\"Could not start recording\", err);\n    }\n  };\n\n  const stopRecording = async (event: MouseEvent | TouchEvent) => {\n    event.preventDefault();\n\n    try {\n      await client.stopContext();\n    } catch (err) {\n      console.error(\"Could not stop recording\", err);\n    }\n  };\n\n  const recordDiv = document.getElementById(\"record\") as HTMLElement;\n  recordDiv.addEventListener(\"mousedown\", startRecording);\n  recordDiv.addEventListener(\"touchstart\", startRecording);\n  recordDiv.addEventListener(\"mouseup\", stopRecording);\n  recordDiv.addEventListener(\"touchend\", stopRecording);\n\n  const initDiv = document.getElementById(\"initialize\") as HTMLElement;\n  client.onStateChange((state: ClientState) => {\n    clientState = state;\n\n    if (state !== ClientState.Connected && state !== ClientState.Disconnected) {\n      initDiv.setAttribute(\"disabled\", \"disabled\");\n    } else {\n      initDiv.removeAttribute(\"disabled\");\n    }\n\n    if (state < ClientState.Connected || state === ClientState.Stopping) {\n      recordDiv.setAttribute(\"disabled\", \"disabled\");\n    } else {\n      recordDiv.removeAttribute(\"disabled\");\n    }\n\n    const statusDiv = document.getElementById(\"status\") as HTMLElement;\n    statusDiv.innerHTML = stateToString(state);\n  });\n}\n\nfunction bindInitialize(client: Client) {\n  const initialize = async (event: MouseEvent | TouchEvent) => {\n    event.preventDefault();\n    const button = event.target as HTMLElement;\n\n    try {\n      if (clientState === ClientState.Disconnected) {\n        await client.initialize();\n        button.innerHTML = \"Disconnect\";\n      } else if (clientState === ClientState.Connected) {\n        await client.close();\n        button.innerHTML = \"Connect\";\n      }\n    } catch (err) {\n      console.error(\"Error initializing Speechly client:\", err);\n    }\n\n    return;\n  };\n\n  const initDiv = document.getElementById(\"initialize\") as HTMLElement;\n  initDiv.addEventListener(\"mousedown\", initialize);\n  initDiv.addEventListener(\"touchstart\", initialize);\n}\n\nfunction resetState(contextId: string) {\n  updateReady(contextId, false);\n\n  const transcript = document.getElementById(\"transcript-words\") as HTMLElement;\n  transcript.innerHTML = \"\";\n\n  const transcriptList = document.getElementById(\n    \"transcript-list\"\n  ) as HTMLElement;\n  transcriptList.innerHTML = \"\";\n\n  const logList = document.getElementById(\"log-list\") as HTMLElement;\n  logList.innerHTML = \"\";\n\n  const entitiesList = document.getElementById(\"entities-list\") as HTMLElement;\n  entitiesList.innerHTML = \"\";\n}\n"],"sourceRoot":""}