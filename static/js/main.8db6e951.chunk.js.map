{"version":3,"sources":["index.ts"],"names":["clientState","ClientState","Disconnected","updateReady","contextId","isReady","readyDiv","document","getElementById","innerHTML","logResponse","type","segmentId","data","logDiv","JSON","stringify","resetState","window","onload","client","appId","process","language","opts","debug","loginUrl","apiUrl","Client","newClient","e","status","statusDiv","updateStatus","message","onSegmentChange","segment","words","entities","intent","map","word","isFinal","value","join","index","entity","t","startPosition","endPosition","onTentativeTranscript","transcript","onTentativeEntities","onTentativeIntent","onTranscript","onEntity","onIntent","startRecording","event","a","preventDefault","startContext","console","error","stopRecording","stopContext","recordDiv","addEventListener","initDiv","onStateChange","state","Connected","setAttribute","removeAttribute","Stopping","stateToString","bindStartStop","initialize","button","target","close","bindInitialize"],"mappings":"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","file":"static/js/main.8db6e951.chunk.js","sourcesContent":["import {\n  Client,\n  ClientState,\n  stateToString,\n  Word,\n  Entity,\n  Intent,\n  ClientOptions,\n  Segment,\n} from \"@speechly/browser-client\";\n\nlet clientState = ClientState.Disconnected;\n\nwindow.onload = () => {\n  let client: Client;\n\n  try {\n    client = newClient();\n  } catch (e) {\n    updateStatus(e.message);\n    return;\n  }\n\n  // High-level API, that you can use to react to segment changes.\n  client.onSegmentChange((segment: Segment) => {\n    updateWords(segment.words);\n    updateEntities(segment.entities);\n    updateIntent(segment.intent);\n\n    if (segment.isFinal) {\n      updateReady(segment.contextId, true);\n    }\n  });\n\n  // This is low-level API, that you can use to react to tentative events.\n  client.onTentativeTranscript(\n    (contextId: string, segmentId: number, words: Word[], transcript: string) =>\n      logResponse(\"tentative_transcript\", contextId, segmentId, {\n        words,\n        transcript,\n      })\n  );\n\n  client.onTentativeEntities(\n    (contextId: string, segmentId: number, entities: Entity[]) =>\n      logResponse(\"tentative_entities\", contextId, segmentId, { entities })\n  );\n\n  client.onTentativeIntent(\n    (contextId: string, segmentId: number, intent: Intent) =>\n      logResponse(\"tentative_intent\", contextId, segmentId, { intent })\n  );\n\n  // This is low-level API, that you can use to react to final events.\n  client.onTranscript((contextId: string, segmentId: number, word: Word) =>\n    logResponse(\"transcript\", contextId, segmentId, { word })\n  );\n\n  client.onEntity((contextId: string, segmentId: number, entity: Entity) =>\n    logResponse(\"entity\", contextId, segmentId, { entity })\n  );\n\n  client.onIntent((contextId: string, segmentId: number, intent: Intent) =>\n    logResponse(\"intent\", contextId, segmentId, { intent })\n  );\n\n  bindStartStop(client);\n  bindInitialize(client);\n};\n\nfunction newClient(): Client {\n  const appId = process.env.REACT_APP_APP_ID;\n  if (appId === undefined) {\n    throw Error(\"Missing Speechly app ID!\");\n  }\n\n  const language = process.env.REACT_APP_LANGUAGE;\n  if (language === undefined) {\n    throw Error(\"Missing Speechly app language!\");\n  }\n\n  const opts: ClientOptions = {\n    appId,\n    language,\n    debug: process.env.REACT_APP_DEBUG === \"true\",\n  };\n\n  if (process.env.REACT_APP_LOGIN_URL !== undefined) {\n    opts.loginUrl = process.env.REACT_APP_LOGIN_URL;\n  }\n\n  if (process.env.REACT_APP_API_URL !== undefined) {\n    opts.apiUrl = process.env.REACT_APP_API_URL;\n  }\n\n  return new Client(opts);\n}\n\nfunction updateWords(words: Word[]) {\n  const transcriptDiv = document.getElementById(\n    \"transcript-words\"\n  ) as HTMLElement;\n\n  transcriptDiv.innerHTML = words\n    .map((word) => (word.isFinal ? `<b>${word.value}</b>` : word.value))\n    .join(\" \");\n\n  const wordsDiv = document.getElementById(\"transcript-list\") as HTMLElement;\n  wordsDiv.innerHTML = words\n    .map((word) =>\n      word.isFinal\n        ? `<li><b>${word.value} [${word.index}]</b></li>`\n        : `<li>${word.value} [${word.index}]</li>`\n    )\n    .join(\"\");\n}\n\nfunction updateEntities(entities: Entity[]) {\n  const entitiesDiv = document.getElementById(\"entities-list\") as HTMLElement;\n\n  entitiesDiv.innerHTML = entities\n    .map((entity) => {\n      const t = `${entity.type} - ${entity.value} [${entity.startPosition} - ${entity.endPosition})`;\n      if (entity.isFinal) {\n        return `<li><b>${t}</b></li>`;\n      }\n      return `<li>${t}</li>`;\n    })\n    .join(\"\");\n}\n\nfunction updateIntent(intent: Intent) {\n  const intentDiv = document.getElementById(\"intent-value\") as HTMLElement;\n\n  intentDiv.innerHTML = intent.isFinal\n    ? `<b>${intent.intent}</b>`\n    : intent.intent;\n}\n\nfunction updateReady(contextId: string, isReady: boolean) {\n  const readyDiv = document.getElementById(\"final\") as HTMLElement;\n\n  if (isReady) {\n    readyDiv.innerHTML = `<b>Context</b> ${contextId} Done!`;\n  } else {\n    readyDiv.innerHTML = `<b>Context</b> ${contextId}`;\n  }\n}\n\nfunction logResponse(\n  type: string,\n  contextId: string,\n  segmentId: number,\n  data: any\n) {\n  const logDiv = document.getElementById(\"log-list\") as HTMLElement;\n\n  logDiv.innerHTML =\n    `<tr>\n          <td>${contextId}</td>\n          <td>${segmentId}</td>\n          <td>${type}</td>\n          <td>${JSON.stringify(data)}</td>\n        </tr>` + logDiv.innerHTML;\n}\n\nfunction updateStatus(status: string): void {\n  const statusDiv = document.getElementById(\"status\");\n  if (statusDiv === null) {\n    return;\n  }\n\n  statusDiv.innerHTML = status;\n}\n\nfunction bindStartStop(client: Client) {\n  const startRecording = async (event: MouseEvent | TouchEvent) => {\n    event.preventDefault();\n\n    try {\n      const contextId = await client.startContext();\n      resetState(contextId);\n    } catch (err) {\n      console.error(\"Could not start recording\", err);\n    }\n  };\n\n  const stopRecording = async (event: MouseEvent | TouchEvent) => {\n    event.preventDefault();\n\n    try {\n      await client.stopContext();\n    } catch (err) {\n      console.error(\"Could not stop recording\", err);\n    }\n  };\n\n  const recordDiv = document.getElementById(\"record\") as HTMLElement;\n  recordDiv.addEventListener(\"mousedown\", startRecording);\n  recordDiv.addEventListener(\"touchstart\", startRecording);\n  recordDiv.addEventListener(\"mouseup\", stopRecording);\n  recordDiv.addEventListener(\"touchend\", stopRecording);\n\n  const initDiv = document.getElementById(\"initialize\") as HTMLElement;\n  client.onStateChange((state) => {\n    clientState = state;\n\n    if (state !== ClientState.Connected && state !== ClientState.Disconnected) {\n      initDiv.setAttribute(\"disabled\", \"disabled\");\n    } else {\n      initDiv.removeAttribute(\"disabled\");\n    }\n\n    if (state < ClientState.Connected || state === ClientState.Stopping) {\n      recordDiv.setAttribute(\"disabled\", \"disabled\");\n    } else {\n      recordDiv.removeAttribute(\"disabled\");\n    }\n\n    const statusDiv = document.getElementById(\"status\") as HTMLElement;\n    statusDiv.innerHTML = stateToString(state);\n  });\n}\n\nfunction bindInitialize(client: Client) {\n  const initialize = async (event: MouseEvent | TouchEvent) => {\n    event.preventDefault();\n    const button = event.target as HTMLElement;\n\n    try {\n      if (clientState === ClientState.Disconnected) {\n        await client.initialize();\n        button.innerHTML = \"Disconnect\";\n      } else if (clientState === ClientState.Connected) {\n        await client.close();\n        button.innerHTML = \"Connect\";\n      }\n    } catch (err) {\n      console.error(\"Error initializing Speechly client:\", err);\n    }\n\n    return;\n  };\n\n  const initDiv = document.getElementById(\"initialize\") as HTMLElement;\n  initDiv.addEventListener(\"mousedown\", initialize);\n  initDiv.addEventListener(\"touchstart\", initialize);\n}\n\nfunction resetState(contextId: string) {\n  updateReady(contextId, false);\n\n  const transcript = document.getElementById(\"transcript-words\") as HTMLElement;\n  transcript.innerHTML = \"\";\n\n  const transcriptList = document.getElementById(\n    \"transcript-list\"\n  ) as HTMLElement;\n  transcriptList.innerHTML = \"\";\n\n  const logList = document.getElementById(\"log-list\") as HTMLElement;\n  logList.innerHTML = \"\";\n\n  const entitiesList = document.getElementById(\"entities-list\") as HTMLElement;\n  entitiesList.innerHTML = \"\";\n}\n"],"sourceRoot":""}